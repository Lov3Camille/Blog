---
layout:     post
title:      "JVM - 几种GC的比较"
subtitle:   " \"JVM Daily Notes - 13\""
date:       2021.01.07 12:29:00
author:     "Wuy"
header-img: "img/post-bg-2020.jpg"
catalog: true
tags:
    - 学习笔记
    - 读书
    - JVM

---

> *"Keep Learning JVM"*

# 堆

## 几种GC的比较

主要包括`Minor GC`, `Major GC`, `Full GC`;

JVM在进行垃圾回收时，并非每次都对三个内存区域一起回收，大部分回收的都是新生代。

针对HotSpot VM的实现，它里面的垃圾回收按照回收区域又分为两大种类型：一部分是部分收集(`Partial GC`)，一部分是整堆收集（`Full GC`）;

- 部分收集：不是完整收集整个Java堆的垃圾收集，其中又分为：
  - 新生代收集(`Minor GC/Young GC`)：只是新生代（`Eden`和`S0/S1`）的垃圾回收；
  - 老年代收集(`Major GC/Old GC`)：只是老年代的垃圾收集；
    - 目前，只有`CMS GC`会有单独收集老年代的行为；
    - 注意，很多时候`Major GC`会和`Full GC`混合使用，需要具体分辨是老年代回收还是整堆回收；
  - 混合收集（`Mixed GC`）: 收集整个新生代以及部分老年代的垃圾收集。
    - 目前，只有`G1 GC`会有这种行为。
  - 整堆回收（`Full GC`）：收集整个堆空间和方法区的垃圾收集。

### `Minor GC`触发机制

1. 当年轻代空间不足，就会触发`Minor GC`，这里的年轻代满指的是`Eden`满，`Survivor`满不会引发`GC`。
2. 该`GC`发生的频率十分的高；
3. `Minor GC`会引发`STW`, 暂停其他用户的线程，等垃圾回收结束，用户线程才恢复运行。

### `Major GC/Full GC`触发机制

1. 指发生在老年代的`GC`，对象从老年代消失时，也就是该回收机制发生了；
2. 老年代空间不足时，一般会先尝试触发`Minor GC`，若空间还不足，则触发老年代的垃圾回收；
3. 该速度比`Minor GC`慢10倍以上，`STW`的时间更长；
4. `Major GC`后空间还不足，则报`OOM`的错误

### `Full GC`的触发机制

调用该垃圾回收共五种情况下会发生：

1. 调用`System.gc()`时，系统建议执行，但不是必须；
2. 老年代空间不足；
3. 方法区空间不足；
4. 经过`Minor GC`后进入老年代的平均大小大于老年代的可用内存；
5. 由新生区内部各区之间复制的时候，对象大小大于`To Space`的可用内存，进而转移至老年代，且老年代的可用内存仍然不足；

注意：`Full GC`是开发或调优中尽量要避免的，因为`STW`时间较长。

## `GC`的举例和日志分析

可以通过JVM的参数`-XX:+PrintGCDetails`查看程序运行过程中的垃圾回收的整个过程。

## 堆空间分代思想

为什么需要把Java堆分代，不分代不可以吗？

- 其实不分代完全可以，唯一的理由就是优化`GC`性能。主要是为了避免每次都对堆的所有区域进行扫描，比如大多数对象都是朝生夕死的，这部分区域就需要高频率的垃圾回收。

## 内存分配策略（对象提升规则）

针对不同年龄段的对象分配原则如下所示：

- 优先分配到`Eden`区；
- 大对象直接分配到老年代：
  - 尽量避免程序中出现大对象；
- 长期存活的对象存放到老年代；
- 动态对象年龄的判断：
  - 如果幸存者区中相同年龄的所有对象的大小的总和大于幸存者区空间的一半，那么所有年龄大于这些对象的对象可以直接进入老年代，无需等待其达到设定的年龄值。
- 空间分配担保：
  - `-XX:HandlePromotionFailure`

## 对象分配过程（TLAB）

为什么需要Thread Local Allocation Buffer?

- 堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据；
- 由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的；
- 为避免多个线程操作同一地址，需要使用加锁等机制，影响了分配速度。

什么是TLAB？

- 从内存模型而不是垃圾收集的角度，对`Eden`区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在`Eden`空间内；

- 多线程同时分配内存时，使用`TLAB`可以避免一系列的非线程安全问题，同时还可以提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略；

- 开发人员可以通过`-XX:UseTLAB`来开启TLAB模式(默认是开启的)；

- 可以通过`-XX:TLABWasteTargetPercent`设置TLAB空间所占用`Eden`空间的百分比，一般是1%;

- 一旦TLAB分配失败，JVM就会尝试通过加锁机制确保数据操作的原子性，从而直接在`Eden`区分配内存。

  







































