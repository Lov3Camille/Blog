---
layout:     post
title:      "JUC - Java中的锁"
subtitle:   " \"JUC Daily Notes - 15\""
date:       2021.02.12 12:29:00
author:     "Wuy"
header-img: "img/post-bg-2020.jpg"
catalog: true
tags:
    - 学习笔记
    - 读书
    - JUC

---

> *"Keep Learning JUC"*

# Java中各种锁的理解

## 公平锁和非公平锁

针对`ReentrantLock`，这两种都有实现：

```java
public ReentrantLock() {
        sync = new NonfairSync(); // 非公平锁
    }
```

```java
public ReentrantLock(boolean fair) {
        sync = fair ? new FairSync() : new NonfairSync(); // 公平锁
    }
```

## 可重入锁

`synchronized`版本:

```java
public class LockTest {

    public static void main(String[] args) {
        Phone phone = new Phone();

        new Thread(() -> {
            phone.sendMessage();
        }, "A").start();

        new Thread(() -> {
            phone.sendMessage();
        }, "B").start();
    }

}

class Phone {

    public synchronized void sendMessage() {
        System.out.println(Thread.currentThread().getName() + "sms");
        callBack();
    }

    public synchronized void callBack() {
        System.out.println(Thread.currentThread().getName() + "call");
    }
}
```

`ReentrantLock`版本：

```java
import java.util.concurrent.locks.ReentrantLock;

public class ReentrantLockTest {

    public static void main(String[] args) {
        Phone2 phone2 = new Phone2();

        new Thread(() -> {
            phone2.sendMessage();
        }, "A").start();

        new Thread(() -> {
            phone2.sendMessage();
        }, "B").start();
    }

}

class Phone2 {

    ReentrantLock lock = new ReentrantLock();

    public void sendMessage() {
        lock.lock();
        try {
            System.out.println(Thread.currentThread().getName() + "sms");
            callBack();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public void callBack() {
        lock.lock();
        try {
            System.out.println(Thread.currentThread().getName() + "call");
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}
```

## 自旋锁

示例代码如下：

```java
import java.util.concurrent.TimeUnit;

public class TestSpinLock {

    public static void main(String[] args) {

        SpinLockTest lock = new SpinLockTest();

        new Thread(() -> {
            lock.setLock();

            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                lock.unLock();
            }
        }, "a").start();

        new Thread(() -> {
            lock.setLock();

            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                lock.unLock();
            }
        }, "b").start();
    }
}
```

输出如下：

```
a==> set lock starts
b==> set lock starts
a==> unlock starts
b==> unlock starts
```

也就是说，这也实现了可重入锁的功能。