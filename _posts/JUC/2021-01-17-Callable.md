---
layout:     post
title:      "JUC - Callable和常用辅助类"
subtitle:   " \"JUC Daily Notes - 05\""
date:       2021.01.17 12:29:00
author:     "Wuy"
header-img: "img/post-bg-2020.jpg"
catalog: true
tags:
    - 学习笔记
    - 读书
    - JUC
---

> *"Keep Learning JUC"*

# `Callable`

![image-20210117202408302](C:/Users/MSI-NB/AppData/Roaming/Typora/typora-user-images/image-20210117202408302.png)

1. 可以有返回值；

2. 可以抛出异常；

3. 与`run()`方法不同，这里是`call()`。

4. 执行方法：

   ```java
   package org.example;
   
   import java.util.concurrent.Callable;
   import java.util.concurrent.ExecutionException;
   import java.util.concurrent.FutureTask;
   
   public class CallableTest {
   
       public static void main(String[] args) throws ExecutionException, InterruptedException {
   
           //new Thread().start();
   
           MyThread thread = new MyThread();
   
           FutureTask futureTask = new FutureTask(thread); // 适配类
   
           new Thread(futureTask, "A").start();
   		new Thread(futureTask, "B").start(); // 结果会被缓存以提高效率
           String result = (String) futureTask.get(); // 获取Callable的返回结果，但可能会产生阻塞，所以一般放到最后/使用异步通信执行
           System.out.println(result);
       }
   }
   
   class MyThread implements Callable<String> {
   
       public String call() throws Exception {
           System.out.println("call() exec");
           return "test";
       }
   
   }
   
   ```

# 常用辅助类

## `CountDownLatch`



![image-20210117211623139](C:/Users/MSI-NB/AppData/Roaming/Typora/typora-user-images/image-20210117211623139.png)

示例如下：

```java
package org.example;

import java.util.concurrent.CountDownLatch;

// 计数器
public class CountDownLatchTest {

    public static void main(String[] args) throws InterruptedException {

        CountDownLatch countDownLatch = new CountDownLatch(6);

        for (int i = 0; i < 6; i++) {
            new Thread(() -> {
                System.out.println(Thread.currentThread().getName() + " go out");

                countDownLatch.countDown(); // 数量减一
            }, String.valueOf(i)).start();
        }

        countDownLatch.await(); // 等待计数器归零，然后再向下执行
        System.out.println("Close Door");
    }
}

```





































